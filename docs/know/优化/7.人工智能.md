# 7.人工智能

[[toc]]

## 7.1 tensorFlow.js



### 7.1.1 基础

```js
--1.Tensors (张量)：类似于js的数组，用来放数据的。不能改变它们的值
 shape：类似于js的length，简单理解成输出几位几行的函数
 
tf.scalar（零维）, tf.tensor1d（一维）, tf.tensor2d（二维）, tf.tensor3d（三维）、tf.tensor4d（四维）以及 tf.ones（值全是1）或者tf.zeros（值全是0）

const shape = [2, 3] // 2维2行3列
const a = tf.tensor([1, 2, 3, 4, 5, 6], shape)
a.print()
 
const b = tf.tensor([[1, 2, 3] ,[4, 5, 6]])
b.print()

--2.variable(变量)
通过张量初始化来的，变量的值是可以改变的

const initValue = tf.zeros([5]);
const a = tf.variable(initValue); // 初始化a
const updatValue = tf.tensor1d([0, 1, 0, 1, 0]);
a.assign(updatValue); // 更新 a的值

Layers (图层)
Optimizers (优化器) 和
损失函数
addons:一些有用的额外功能



```



### 7.1.2 内存管理

```js
在 TensorFlow.js 中，我们可以通过 dispose 和 tf.tidy 这两种方法来管理内存
--1.dispose
const x = tf.tensor2d([[0, 2], [4, 6]]);
const x2 = x.square();
x.dispose();
x2.dispose();

2.tf.tidy
tf.tidy执行一个函数并清除所有创建的中间张量，释放它们的GPU内存。 它不清除内部函数的返回值。
```





### 7.1.3 创造模型

```js
创造模型的办法由两种。
--1.是通过ops的方法创造模型（类似于序贯模型）
就是要构造卷积层 xx层之类的（ tf.scalar(2);）

--2.通过高级API tf.model 来创建一个模型（）
tf.sequential();


```

### 7.1.4 线性模型 | 多线性莫i选哪个

```js
4步
注意一下，4.2 版本的tf 有问题

 <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.1.0/dist/tf.min.js"></script>
// step1：数据预处理 | 多线性模型 tensorflow 就要用 dataset 数据集（训练模型的fit 的 时候传入进去）
// step2：创造模型 
// step3：开始训练
// step4:开始推理

封装示例

class deepStudy {
    constructor() {
        this.model = null
        this.data = null
        this.dataReady()
        this.modelCreate()
        this.train()
        // this.infer()

    }
    // step1：数据预处理
    dataReady() {
        //   tf.util.shuffle(this.data);
        // 转换为张量 这里我们制作两个数组，一个用于我们的输入示例，另一个用于真正的输出值（在机器学习中称为标签）。

        let origin_data = [800, 850, 900, 950, 980, 1000, 1050, 1075, 1100, 1150, 1200, 1250, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000];
        let last_answers = [800000, 850000, 900000, 950000, 980000, 1000000, 1050000, 1075000, 1100000, 1150000, 1200000, 1250000, 1300000, 1400000, 1500000, 1600000, 1700000, 1800000, 1900000, 2000000];

        // 测试数据集
        const dataTest = [886, 1225, 500];
        const answersTest = [886000, 1225000, 500000];

        this.trainTensors = {
            data: tf.tensor2d(origin_data, [origin_data.length, 1]),
            answer: tf.tensor2d(last_answers, [last_answers.length, 1])
        };

        this.testTensors = {
            data: tf.tensor2d(dataTest, [dataTest.length, 1]),
            answer: tf.tensor2d(answersTest, [answersTest.length, 1])
        };


    }
    // step2：创造模型
    modelCreate() {
        // 创造一个 序贯模型(Sequential) 
        this.model = tf.sequential();
        this.model.add(tf.layers.dense({ inputShape: [1], units: 1 }));

        this.LEARNING_RATE = 0.01;
        this.EPOCHS = 50;

        // BatchSize refers to the size of the data subsets that the model 
        // will see on each iteration of training.
        this.BATCH_SIZE = 8;


        // Add a single hidden layer 添加层
        // model.add(tf.layers.dense({units: 50, activation: 'sigmoid'})); 在这种情况下是sigmoid激活
        // this.model.add(tf.layers.dense({ inputShape: [1], units: 1, useBias: true }));
        // Add an output layer
        // this.model.add(tf.layers.dense({ units: 1, useBias: true }));
        return this.model
    }
    // step3：开始训练
    async train() {
        this.model.compile({
            optimizer: tf.train.sgd(this.LEARNING_RATE),
            loss: 'meanAbsoluteError'
        });
        let results = await this.model.fit(this.trainTensors.data, this.trainTensors.answer, {
            epochs: this.EPOCHS,
            batchSize: this.BATCH_SIZE,
            shuffle: true,
            validationSplit: 0.1
        });

        console.log('training complete');
        this.infer()
    }
    // step4:开始推理
    infer() {
        // 推理的初始数据
        let predValue = 768;
        let answer = this.model.predict(tf.tensor1d([predValue]));
        answer.print();

        let nonTensorRepresentation = answer.dataSync();
        console.log("预测的y：",Math.floor(nonTensorRepresentation[0]));

        // 求预测的准确值
        let result = this.model.evaluate(this.testTensors.data, this.testTensors.answer);
        let testLoss = result.dataSync()[0];
        console.log('Test loss: ' + testLoss);
    }
}
    let model = new deepStudy()
```

