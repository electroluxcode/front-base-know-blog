# 1.计算机网络

[[toc]]

## 1.1 常识

### 1.1.1 osi  |  tcp/ip

```js
--1.OSI七层协议物理层、数据链路层、网络层（IP）、传输层（TCP和UDP）、会话层、表示层、应用层（HTTP、WebSocket、FTP、DNS）

--2.TCP/IP 5层协议族按层次分为应用层、传输层、网络层和数据链路层 物理层
TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。
```





### 1.2.2 get post

```js
1.GET 和 POST ⽅法都是安全和幂等的吗？
在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。所谓的「幂等」，意思是多次执⾏相同的操作，结果都是「相同」的。那么很明显 GET ⽅法就是安全且幂等的，POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。
2.
```



### 1.2.3  tcp 常问

```js
1.TCP/IP协议了解吗?说一下层次结构？TCP/IP是怎么做到分层的？
比osi少了会话层和表示层。 我当时忘了有两个协议OSI七层协议和这玩意

2.为什么需要 TCP 协议？ TCP ⼯作在哪⼀层？可靠性，传输层

3.什么是 TCP ？ 面向连接的（只能一对一），可靠的（使命必达），基于字节流的通信协议（字节组成，无边界-就是多大都可以）

4.UDP 和 TCP 有什么区别呢？分别的应⽤场景是？
--4.1 连接：UDP 利⽤ IP 提供⾯向「⽆连接」的通信服务，TCP面向连接的的可靠的
--4.2 可靠：UDP 到达不可靠
--4.3 控制：拥塞控制和流ᰁ控制机制，保证数据传输的安全性
--4.4 传输方式：UDP是包发送+分片（网络层分片）   TCP 是流式传输+分片（传输层分片）
传输层

5.如何在 Linux 系统中查看 TCP 状态？
netstat -napt

6.为什么一定要三次握手？不使⽤「两次握⼿」和「四次握⼿」的原因：
--6.1 RFC规范：防止旧的重复连接初始化造成混乱。如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接 （时间通道）
--6.2 同步双⽅初始序列号(物理通道)-避免资源浪费

7.什么是 SYN 攻击？如何避免 SYN 攻击？
--what 假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，⽆法得到未知 IP 主机的 ACK 应答，久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务。
--how 
通过修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理

8.初始序列号 ISN 是如何随机产⽣的？
ISN = M（每隔4s+1的计时器。male） + F（Hash 算法，根据源 IP、⽬的 IP、源端⼝、⽬的端⼝⽣成⼀个随机数值 female）

9.为什么四次挥手
服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次。

10.为什么 TIME_WAIT 等待的时间是 2MSL？
MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。（⼀来⼀回）

11.为什么需要 TIME_WAIT 状态
主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态
--11.1 保证连接正确关闭
--11.2 防⽌旧连接的数据包
此时如果客户端 TIME-WAIT过短或没有，则就直接进⼊了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK 状态。
当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程就会被终⽌。
2.Tcp第三次握手可不可以携带数据？
第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的
```

### 1.2.4  tcp 机制

```js
1.重传机制:通过序列号与确认应答.设定⼀个定时器，当超过指定的时间后，没有收到对⽅的 ACK 确认应答报⽂，就会重发该数据，也就是我们常说的超时重传。
2.滑动窗口:窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送数据的最⼤值，窗的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。
3.流量控制:通信双⽅各声明⼀个缓存⼤⼩的窗口
4.拥塞控制;就是控制⾃⼰，也即控制发送的速度。不能改变世界，就改变⾃⼰嘛
```



### 1.2.5 其他知识点

```js
1.HTTP长连接的缺点?
可能会损害服务器的整体性能，如apache的长连接时间的长短，直接影响到服务器的并发数。
2.HTTP2是如何解决“队头阻塞”的问题？
HTTP2 并没有解决 TCP 的队首阻塞问题，它仅仅是通过多路复用解决了以前 HTTP1.1管线化请求时的队首阻塞。

HTTP2 是通过分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题

TCP 的阻塞问题是因为传输阶段可能会丢包，一旦丢包就会等待重新发包，阻塞后续传输

```

