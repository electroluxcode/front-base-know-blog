# 2.JavaScript基础

[[TOC]]








## 2.1基础知识

### 2.1.0 基础概念

```js
--0.
ECMA：一个组织
TC39:ECMA下面的技术委员会
stage0（strawman）:任何TC39的成员都可以提交。
stage1（proposal），进入此阶段就意味着这一提案被认为是正式的了，需要对此提案的场景与API进行详尽的描述。
一共是0-4 . 5个阶段。 到达最后一个阶段就进行发布了
常用的 
--0.1 Top-level await（stage 4）：支持最顶层使用await
--0.2 Temporal（stage 3）：时间处理函数标准化 函数
--0.3（stage3） at ： 负索引
--0.4 Record & Tuple（stage2） ：Record类似于对象，Tuple类似于数组
--0.5 Decorators (stage 2)：装饰器
--0.6 Set Methods (stage 2)：基于交集/并集/差集创建新的Set的方法
--0.7 orient-error编程的一系列接口
--0.8 Pipeline Operator：管道操作符（|>） 如doubleNumber(number)会变为number |> doubleNumber的形式

1.作用域又叫做执行上下文，全局上下文就是window对象
2.6个基础数据类型:undefine number string boolean symbol  null。
```



### 2.1.1.线程与进程(开销和内存空间)？JS为什么是单线程的？(避免dom带来的同步问题)

   线程是CPU调度的基本单位，本质是指令序列。进程是操作系统分配资源的单位。二者区别在于线程执行开销小但不利于资源管理和保护，进程则相反。本质区别在于线程没有自己的内存空间，而进程有。
   为避免频繁操作DOM带来的同步问题，设计成单线程。后来为了利用多核CPU计算能力，HTML5提出Web Worker标准，允许js脚本创建多个线程，但是子线程由主线程控制且不得操作DOM，所以JS单线程的本质没有改变。

### 2.1.2.var,let,const

   var函数作用域，let块作用域，const也是块作用域，但定义后不可重新赋地址

```js
注意const比较特殊
var 变量提升。只有声明没有赋值

暂时性死区:let const没有声明变量却引入。实例化到被创造的过程。因为只要有let const就会优先实例化。根本原因:变量的生命先于使用。（块级作用域）

var会变成window的值。

const只保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个复合类型的变量声明为常量必须非常小心。
例如以下：
const arr = [];
// 报错，[1,2,3]与[]不是同一个地址
arr = [1,2,3];
const arr = [];
// 不报错，变量名arr指向的地址不变，只是数据改变
arr[0] = 1;

// 块级作用域的东西
var a = 20 ;
{
    console.log(a)  // 输出 function
    // 重要 块级作用域中 function 之后的就只能在这个块级作用域了，出不了外面
    a = 30
    function a(){
        console.log("aaaa")
    }
    console.log(a)  // 输出 30
    a = 40
    console.log(a)  // 输出 40
}
console.log(a)  // 输出30 。如果是 let a = 20 那么这里
//safari 是 40
//google 和 firefox 是 30


//---------------------------------------------
var a = 20 ;
{
    a = 30
    console.log(a)  // 输出30
    a = 40
    console.log(a)  // 输出40
}
console.log(a)  // 输出40



```



### 2.1.3.null和undefined

   布尔值都是false，都是基础类型，undefined代表未定义的值，null表示被认为设置为空的值，例如释放一个对象的内存用null，或者获取一个不存在的dom对象。

{} 不是空对象

###   2.1.4.原生v-for

```js
var str1 = '';//自定义字符串,用于拼接标签
var data = {
    "textArr":[
        {"grade":'一等品',"mix":'20%',"number":'200'},
        {"grade":'准一等品',"mix":'20%',"number":'200'},
    ],
};
for(let i=0;i<data.textArr.length; i++){
    str1 += `<h1>${data.textArr[i].grade}</h1>`
}
document.getElementById("container").innerHTML = str1
```



### 2.1.5.闭包(2点)-引用+访问上层

**--1.外层函数作用于对象能保留下来是因为被内层函数对象的作用域引用者，无法释放。**

**--2.能访问上级函数作用域中的变量（哪怕上级函数上下文已经销毁）**

```javascript




```

### 2.1.6.this

```js
记前三个：我理解是用来数据绑定
1.this 绑定在函数 运行时 所在的对象,谁调用指向谁
2.事件绑定的this指向事件源
3.构造函数的this指向实例化对象
4.定时器的this指向window

通过bind，call，apply来改变this
```

   全局作用域中指向window，箭头函数没有自己的this（所以不能用作构造函数）
   优先级：new绑定>显式绑定>隐式绑定。



this有四种，第一种 默认绑定

```
运行在非严格模式的独立空间里面,this指向全局对象。
运行在严格模式下，this会绑定到undefined
```


第二种：隐式绑定（租房子）

```js
当函数引用有上下文对象时。对象属性引用链中只有上一层或者说最后一层在调用中起作用
隐式绑定规则会把函数中的this绑定到这个上下文对象
function foo(){
	console.log(this.a);
}
var obj = {
	a:2,
	foo:foo
};
obj.foo();//2

//小心一下隐式丢失这一种情况，像上面这一种情况如果把最后两行变成.参数传递也会有这种情况.主要的原因很有可能是被同级的window对象夺走了参数
var a=3;
let fun=obj.foo
fun()//3



var obj = {
	a:2,
	foo:function foo(){
	console.log(this.a);
	}
};
var a=6
obj.foo();//2
obj.a=6
obj.foo();//6
```



第三种:显式绑定（买房子）

```js
通过call(..) 或者 apply(..)方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。

function foo(){
	console.log(this.a);
}
var obj ={
	a:2
}
foo.call(obj);//2  调用foo时强制把foo的this绑定到obj上
```

第四种：new绑定

```
第一步:创造空对象    第二步：赋值prototype   第三步：赋值this
```





### 2.1.7.柯里化

   指一个函数接收函数A并且返回一个函数B，函数B来处理A的剩余参数。例如f(x,y)=x^y，固定x=2就得到f(y)=2^y这样的新的函数。具体的代码放在 4.javascript-手写题.md里面



### 2.1.8.深浅拷贝

   在拷贝对象或数组时，深浅拷贝不一样。浅拷贝拷贝对象A时，会先创建一个新对象B，如果对象A的某个属性对应的值是一个对象C，那么只复制对象C的引用，不会递归往下复制，对象C还是共享同一块内存，所以修改对象A中的对象C会改变新对象B的对象C。但深拷贝会另外创造一个一模一样的对象C2，新对象C2跟原对象C不共享内存，修改对象C不会改变新对象C2。

```javascript
function deepclone(obj){
    // step1:过滤function
    if(typeof obj !="object") return obj;
    // step2:初始变量
    let arr = Array.isArray(obj) ? [] : {}
    // step3 :
    for(let index in obj){
       arr[index] = deepclone(obj[index])
    }
    return arr
}


let a = {id:1,name:{first:"xiaoming"},fun:function fun(){}}
let b = deepclone(a)
let c = deepclone(a)
b.name.first = 5
console.log(b,c)




// 该方法简单但有bug，因为JSON.stringify会忽略值为undefined、symbol的属性
function deepClone2(obj) {
  return JSON.parse(JSON.stringify(obj))
}


```

### 2.1.9.作用域链   | 执行上下文

```js
变量提升把变量或者是function的声明提升到开头的行为。所以我们会用 块级作用域，let 和 const来防止变量提升

原理是 预编译 和 执行
--1.作用域一共有三个 全局作用域、函数作用域，块级作用域。函数的 { }，才能形成作用域，比如
// 比如这个对象的 { } 就不是作用域
var xiaoming = { 
  name: 'xiao ming' // 对象中的属性，也不是局部变量
}
一些特殊例子
if (false) {
  var a = 10
}
console.log(a) // 会输出 undefined
{
  var b = 1
}
console.log(b) // 会输出 undefined

--2.块级作用域和{} 合并 示例
{
  let x = 0
}
console.log(x) // Uncaught ReferenceError: x is not defined

--2.作用域链：作用域链是如果在当前作用域下找不到该变量，那就去上层作用域去寻找，直到全局作用域，如果还找不到会报错

为什么在对象内部访问自己的属性不能直接用xxx，为什么 this 指向的不是 window
const xiaoming = {
  name: '小明',
  getName: function () {
    console.log(name)
  }
}
xiaoming.getName() // undefined

因为只有函数的大括号{}才能形成作用域，

--3 说明会先在内部找，接下来回到外部找
--3.1
let a = 56
function b(){
    console.log(a)
    //var a =12
}
b()  //输出56

--3.2
let a = 56
function b(){
    console.log(a)
    var a =12
}
b()  //输出 undefined
```



   作用域是变量和函数生效的区域，分为全局作用域、函数作用域和块级作用域
   ，如果在非严格模式下会在全局隐式地声明该变量













### 2.1.10.原型链

__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链

```js
prototype（只能没有实例的时候用）、__proto__与constructor（只能class）
我们需要牢记两点：
--1.__proto__和constructor属性是对象所独有的；
--2. prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。
--3.区别主要是 
new之前：prototype的属性会得到继承。__proto__的属性不会得到继承
new之后：prototype的属性设置不了（会报错）。__proto__的属性随便设置，设置的也是改变目前的prototype

// a.__proto__.__proto__.__proto__ 可能会报错 在报错的最后一次返回的是null
原型链的尽头是object的隐式原型null
//a.constructor.constructor.constructor 永远不报错。最后返回的是native code

let test1 = function(){
    this.name = 'function'
}
let protest=new test1()
protest.__proto__.name = 'function1';

class test2 {
  constructor() {
      this.name="class"
  }
}
let ex2 = new test2()
ex2.__proto__.name="ss" //这个没有问题
```

   每个对象都有一个原型对象，当访问一个对象的属性时，不仅会在该对象上搜寻，还会去该对象的原型上搜索。在我们new 对象的时候，第一步是创造内存空间，接下来是原型挂载。最后是

```javascript
function Person() {
    this.name = 'tom'
}
Person.prototype.name = 'Kevin';
var person = new Person();
person.name = 'Daisy';
console.log(person.name) // Daisy
delete person.name;
console.log(person.name) // Kevin

// 同样的基于原型链的属性查找还有constructor,funciotn原型对象Person是有constructor属性的，但是实例对象person没有，但是可以打印出person.constructor


```



```js
//只有函数才有prototype原型属性，protype是一个对象。实例可以共享函数的原型。当前实例对象找不到属性就回去原型里面去找属性。默认有一个construct

//JavaScript的prototype是仅函数拥有, 而对象也拥有prototype是源于其constructor属性所拥有的prototype.
```





### 2.1.11.继承

   一般基于原型链或者构造函数继承，用的最多的是综合前两者的组合继承，最优的是寄生组合继承

```js
--1.原型链继承（但无法多继承，也不能向构造函数传参）
function People(name) {
    this.name = name || 'Annie'
   
}
function Student() {
}
Student.prototype = new People()

--2.构造函数继承（父类原型链上的参数不能访问，但可以多继承，也可以向构造函数传参）
function Student(name) {
    People.call(this, name) 
}
People.prototype.age = 18
let student = new Student('Tom') // 打印一次People
console.log(student.name) // Tom
student.eat('apple') // 访问不到父类原型链上的参数，报错没有该函数

--3.ES6 class extends 继承

```


2.instanceof
   用法：object instanceof constructor

```js
function f(obj) {console.log(Object.prototype.toString.call(obj))}
// [object xxxxx]是string类型
f(1) 							// [object Number]
f('1') 						// [object String]
f(false) 					// [object Boolean]
f(undefined) 			// [object Undefined]
f(null) 					// [object Null]
f(Symbol()) 			// [object Symbol]
f({name: 'jack'}) // [object Object]
f([1,2,3]) 				// [object Array]
f(new Date()) 		// [object Date]
f(/a/) 						// [object RegExp]
```

### 2.1.12.Symbol

   常用来创建唯一不变的属性名，`Symbol()`用来创建symbol类型的变量，注意不是`new Symbol()`，传入的参数没啥用只能用来标识提醒程序员。使用`getOwnPropertySymbols()`可获得Symbol属性。

```javascript
let sym = Symbol()
let obj = {}
// 这里必须配合字面量创建属性
obj[sym] = 1
console.log(obj.sym) // undefined
console.log(obj[sym]) // 1
```

### 2.1.13.new操作符 | 手写


```js
   new用来创建一个给定构造函数的实例对象
   流程： 
   1.声明空对象 
   2.如果是数组，那么就挂载原型（将空对象的__proto__指向构造函数的prototype）。如果是方法，那么调用apply方法 
   3.赋值给this
function myNew(Funct, ...args) {
    let obj = {}
    obj.__proto__ = Funct.prototype
    let res = Funct.apply(obj, args)
    return res instanceof Object ? res : obj
}
```



### 2.1.14.函数式编程

   函数式编程是一种编程范式，主要的编程范式还有命令式编程（一步步告诉怎么做）和声明式编程（sql语句，html，css）
   函数式编程更强调程序执行的结果而非执行过程，倡导基于输入输出的集合转换关系。
   缺点是过度包装带来的性能下降，资源占用压力也大，容易陷入递归陷阱



### 2.1.15. 时间复杂度

   快速排序时间复杂度为nlogn，

1 3



### 2.1.16.事件循环(3个概念)

**调用栈(call stack)、消息队列(Message Queue)和微任务队列(Microtask Queue)**

**1.**Event Loop 开始时，从上到下，遇到函数调用时，会把函数压入调用栈中（被压入的函数叫做`帧(frame)`，当函数返回后，会从调用栈中弹出。直到被清空

**2. **微任务队列（Microtask Queue）：使用 Promise、Async/Await 创建的异步操作会入队到微任务队列中

**3**.调用栈被清空清空执行。异步操作进入消息队列（settimeout，setinterval）

```js
//1.事件循环定义：我们先把代码分成同步代码（console.log）和异步代码(setimeout，promise的then)。同步代码我们交给js（执行栈）去执行（因为这玩意是单线程的），异步环境我们交给宿主环境去执行。异步环境条件满足之后我们从宿主环境推送到任务队列。执行栈里面的任务执行完了，我们就会把任务队列（里面有宏任务队列和微任务队列）的任务推进执行栈。执行栈执行完就去任务队列看看，这个就叫做事件循环

//2.异步任务分成宏任务和微任务。宏任务由宿主环境组成(浏览器，node)。微任务由js引擎组成。优先级：同步代码-》微任务异步promise.then，await，nexttick也是。后面的也是-》宏任务异步.

//3.我看的疑问：为什么宏任务微任务是微任务优先：其实上面的说法忽略了一个条件。所有的任务都是在一个大的script里面产生的

//4.promise本身是同步的但是里面的.then是异步的
new Promise(resolve => {
        console.log(1);
        resolve(console.log(4)); //下面代码不会被阻止。会调用.then函数，先进先出原则
    	console.log("我")
        Promise.resolve(console.log("是")).then(()=> {
            console.log(3);
            Promise.resolve(console.log("s")).then(()=> {
            	console.log("b");
            })
        })
    }).then(num => {
        console.log(num);
        setTimeout(()=>{console.log(5)},0);
});
console.log(2); // 1 我 是 2 （第一个同步）| 3（第一个异步，then先进先出）|  s（第二个同步）  | 4 （这里是由于resolve只能一个then，不继续惯着了）| b 5
//先同步，resolve中的也是同步（resolve作为参数不阻塞）。 
//先到then的


new Promise(resolve => {
        console.log(1);
        resolve(3); //下面代码不会被阻止。会调用.then函数，先进先出原则
        Promise.resolve().then(()=> console.log(4))
    }).then(num => {
        console.log(num);
        setTimeout(()=>{console.log(6)},0);
});
console.log(2); // 1 2 4 3 6  注意一下 1是最先执行的


var p = new Promise((resolve) => {
  console.log(4);
  resolve(5);
});

function func1() {
  console.log(1);
}

function func2() {
  setTimeout(() => {
    console.log(2);
  });
  func1();
  console.log(3);
  p.then((resolved) => console.log(resolved));
}
func2();  // 4 1 3 5 2 这里主要是 一开始的 p 是会执行的



//----------------------------------------------------------
// 最后加上await 总结一下,
step1:先是 
同步任务 | 
resolve | 
resolve 的任务同时执行例如 resolve(console.log(66))。如果说resolve(4),那么就先执行后面的如果后面是resolve().then(log(55)) 那么就先输出55，接下来执行resolve(4)的.then | 
await 的处理
v8引擎之前 执行 await 后，会把后面的代码注册到微任务队列。
v8引擎之后 执行await 后，直接跳出函数，在本轮循环的最后被执行 |
注意，这些一些遇到微任务直接丢进去 微任务队列。然后遵循 先进先出的 原则
step2: 异步的微任务 （先进先出）
step3：宏任务
```



### 2.1.17 && |  ||

```
&&返回第二个有效值，||返回第一个有效值
```



### 2.1.18  bind  | apply |  call

bind是绑定（用于click）

call后面+单个

apply是+list（块）



### 2.1.19 类型判断 |  类型转化

```js
类型判断
let a=[1,5,6]
1.Object.prototype.toString.call(a)：装箱操作
会对非null 或 undefined的数据类型进行装箱操作（不然会直接报错），然后去找出对象【Symbol.toStringTag】 属性值，还有可能要遍历原型链，取到的值作为 tag, 然后返回 "【object " + tag + "】" 形式的字符串

2. instanceof
返回true

3.typeof
返回用来说明变量的数据类型（但是array，null等复杂对象一律返回object），但是null并不是object格式的

4.isArray

5.nan！=nan结果是true

类型转化
--1.boolean
布尔值转化-用boolean直接转换：这里注意一下如果object={}，那么这个object的给boolean判断的话是true的。真正的空对象会用null来表示。所以空对象返回的是true。

--2.toString
字符串转化:tostring，String直接转化。tostring不支持null和undefined（会报错），string这个构造函数可以直接返回null和undefined的字面量

注意 
145.toString()会报错
但是(145).toString不会报错

--3.number
数值转化：number这个构造函数也是宽容，原理是用valueof先试一下，得不到在调用tostring类型。parseint parsefloat就没有那么宽容了。如果失败会用nan兜底。一个奇怪的点是如果number（空对象）结果是nan

typeof typeof typeof null 的结果是什么
从右边到左边执行：typeof typeof typeof null 结果是 typeof null 先变成'object'然后再变成'string'.答案也是 'string'
```



























### 2.1.24 set | get | Attribute

```js
document.getElementById('content_views').setAttribute('age', 25);
document.getElementById('content_views').getAttribute('class')
```

### 2.1.25  事件委托 | addEventListener

```js
事件委托主要用来1.减少内存消耗，2.动态绑定事件。减少重复工作
我们一般说的事件委托其实是addEventListener
第一个是我们的事件：比如click，mouseover
第二个是方法
第三个是模式。true是事件在捕获阶段执行。事件在冒泡阶段执行，默认是false,就是默认在冒泡的时候执行
//默认冒泡是 标签的onclick事件->document.onclick->addEventListener
//为true的时候 addEventListener->标签的onclick事件->document.onclick 　
```

 事件传播的三个阶段

```
1、捕获阶段：事件从window对象自上而下向目标节点传播的阶段；
2、目标阶段：真正的目标节点正在处理事件的阶段；
3、冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。
```

示例

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div onclick="parent()">
        <ul class="list" >
            <a href="www.baidu.com">百度</a>
            <a href="www.baidu.com">搜狐</a>
        </ul>
    </div>
    <script>
        function parent(){
            console.log("dsadas")
        }
        document.querySelector('.list').addEventListener('click',(e)=>{
            // alert((e || window).event.target.innerHTML)
            // 阻止冒泡方法  不让事件向documen上蔓延。
            // 只激活内部函数,顶部的onclick就不会执行力
            e.stopPropagation()
            // 阻止默认行为
            e.preventDefault()
        })

    </script>
</body>
</html>
```



#### 事件大全

```js
鼠标事件
click 当用户点击某个对象时调用的事件句柄。
contextmenu 在用户点击鼠标右键打开上下文菜单时触发
dblclick 当用户双击某个对象时调用的事件句柄。
mousedown 鼠标按钮被按下。
mouseenter 当鼠标指针移动到元素上时触发。
mouseleave 当鼠标指针移出元素时触发
mousemove 鼠标被移动。
mouseover 鼠标移到某元素之上。
mouseout 鼠标从某元素移开。
mouseup 鼠标按键被松开。

键盘事件
属性 描述 DOM
keydown 某个键盘按键被按下。
keypress 某个键盘按键被按下并松开。
keyup 某个键盘按键被松开。

框架/对象（Frame/Object）事件
abort 图像的加载被中断。 ( )
beforeunload 该事件在即将离开页面（刷新或关闭）时触发
error 在加载文档或图像时发生错误。 ( , 和 )
hashchange 该事件在当前 URL 的锚部分发生修改时触发。
load 一张页面或一幅图像完成加载。
pageshow 该事件在用户访问页面时触发
pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发
resize 窗口或框架被重新调整大小。
scroll 当文档被滚动时发生的事件。
unload 用户退出页面。 ( 和 )

表单事件
blur 元素失去焦点时触发
change 该事件在表单元素的内容改变时触发( , , , 和 )
focus 元素获取焦点时触发
focusin 元素即将获取焦点是触发
focusout 元素即将失去焦点是触发
input 元素获取用户输入是触发
reset 表单重置时触发
search 用户向搜索域输入文本时触发 (

剪贴板事件
copy 该事件在用户拷贝元素内容时触发
cut 该事件在用户剪切元素内容时触发
paste 该事件在用户粘贴元素内容时触发

打印事件
afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发
beforeprint 该事件在页面即将开始打印时触发

拖动事件
drag 该事件在元素正在拖动时触发
dragend 该事件在用户完成元素的拖动时触发
dragenter 该事件在拖动的元素进入放置目标时触发
dragleave 该事件在拖动元素离开放置目标时触发
dragover 该事件在拖动元素在放置目标上时触发
dragstart 该事件在用户开始拖动元素时触发
drop 该事件在拖动元素放置在目标区域时触发

多媒体（Media）事件
abort 事件在视频/音频（audio/video）终止加载时触发。
canplay 事件在用户可以开始播放视频/音频（audio/video）时触发。
canplaythrough 事件在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发。
durationchange 事件在视频/音频（audio/video）的时长发生变化时触发。
emptied The event occurs when the current playlist is empty
ended 事件在视频/音频（audio/video）播放结束时触发。
error 事件在视频/音频（audio/video）数据加载期间发生错误时触发。
loadeddata 事件在浏览器加载视频/音频（audio/video）当前帧时触发触发。
loadedmetadata 事件在指定视频/音频（audio/video）的元数据加载后触发。
loadstart 事件在浏览器开始寻找指定视频/音频（audio/video）触发。
pause 事件在视频/音频（audio/video）暂停时触发。
play 事件在视频/音频（audio/video）开始播放时触发。
playing 事件在视频/音频（audio/video）暂停或者在缓冲后准备重新开始播放时触发。
progress 事件在浏览器下载指定的视频/音频（audio/video）时触发。
ratechange 事件在视频/音频（audio/video）的播放速度发送改变时触发。
seeked 事件在用户重新定位视频/音频（audio/video）的播放位置后触发。
seeking 事件在用户开始重新定位视频/音频（audio/video）时触发。
stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。
suspend 事件在浏览器读取媒体数据中止时触发。
timeupdate 事件在当前的播放位置发送改变时触发。
volumechange 事件在音量发生改变时触发。
waiting 事件在视频由于要播放下一帧而需要缓冲时触发。

动画事件
animationend 该事件在 CSS 动画结束播放时触发
animationiteration 该事件在 CSS 动画重复播放时触发
animationstart 该事件在 CSS 动画开始播放时触发

过渡事件
transitionend 该事件在 CSS 完成过渡后触发。

其他事件
message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发
online 该事件在浏览器开始在线工作时触发。
offline 该事件在浏览器开始离线工作时触发。
popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 event occurs when the window’s history changes
show 该事件当

元素在上下文菜单显示时触发
storage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发
toggle 该事件在用户打开或关闭 元素时触发
wheel 该事件在鼠标滚轮在元素上下滚动时触发
```

### 2.1.27 babel 和 polyfill和core.js

```
Babel 能为你做的事情：
1.语法转换
2.通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 @babel/polyfill 模块)
那么他是咋做到的呢？这就不得不提大名鼎鼎的AST了-parsing(解析)、transforming（转化）、printing（生成）-黑海谈判。日本和美国谈判。但是只有荷兰翻译


polyfill(补丁/垫片) 的定义， 他就是把当前浏览器不支持的方法通过用支持的方法重写来获得支持。

core.js 和polyfill类似。每年会出现新的qpi，像：es6的Promise，Set或者es7数组新提供的方法includes，这些新加入的api，就引出一个词“”polyfill“”(垫片/补丁)，就是社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。新功能转换为大部分现代浏览器都可以支持运行的api补丁包集合。


```

### 2.1.28 懒加载

insertsectionobsserver：减少reflow
基础类型存在栈内存，引用类型存在堆内存
赋值跟浅拷贝的区别：前者共享内存。后者复制第一层



### 2.1.30 async | await | 版本差异 | node 的事件循环比较

用同步的方法实现异步操作（指的是.then）。async返回一个promise，await后面接promise那么就是等待返回结果。async只能和await合并使用。但是浏览器调试await可以单独使用



```js
--1.原理
async/await：原理是包裹一层生成器调用next方法+promise。

--2.版本差异
v8引擎之前 执行 await 后，会把后面的代码注册到微任务队列。
v8引擎之后 执行await 后，直接跳出函数，在本轮循环的最后被执行

console.log('script start') // 1
async function async1() {
    await async2() //3
    console.log('async1 end')
}
async function async2() {
    console.log('async2 end') //3
    return Promise.resolve().then(()=>{
        console.log('async2 end1')
    })
}
async1()//2

setTimeout(function() {
    console.log('setTimeout')
}, 0)

new Promise(resolve => {
    console.log('Promise')
    resolve()
})
.then(function() {
    console.log('promise1')
})
console.log('script end')
// script start  (这里容易，就是普通输出)
// async2 end  (这里容易，就是普通await 的 值，这里promise.then是微任务跳过)
// Promise	（resolve 是同步任务执行）
// script end （同步任务的最后一步）
// async2 end1 （异步任务 的 第一个微任务）
// promise1 （异步任务 的 第二个微任务）
// async1 end （？？？ await 後面的会在本轮循环的最后进行执行，但是再慢也比settimeout快）
// setTimeout
```



```
两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。
```





### 2.1.31 可视区域判断 | dom 偏移 | IntersectionObserver | scolltop | clientheight | offsetheight

```js
1.document.documentElement.clientHeight获取屏幕可视窗口高度。
2. ele.offsetTop  元素相对于文档顶部的距离  //document.querySelector('#user-content').offsetTop  
3.document.documentElement.scrollTop 滚动条滚动的距离  通过上面三个能够知道我们我们是否能够看到视图.但是这样子监听会照成回流。（判断元素位置我们可以通过3+1>2）
document.documentElement.clientHeight(可见区域高）+document.documentElement.scrollTop(用户滑动的距离)  > 观测元素.offsetTop(元素距离顶部的距离)

4.IntersectionObserver 



const io = new IntersectionObserver(ioes => {
  ioes.forEach(ioe => {
    const el = ioe.target;
    const intersectionRatio = ioe.intersectionRatio;
    if (intersectionRatio > 0 && intersectionRatio <= 1) {
      console.log("能看见元素")
    }else{
        console.log("看不见")
    }
    el.onload = el.onerror = () => io.unobserve(el);
  });
});
const imgs = Array.from(document.querySelectorAll('#user-content--getboundingclientrect'));
imgs.forEach(item => io.observe(item))


```



利用offsetTop和scrollTop和浏览器高度做比较
getBoundingClientRect返回相关位置属性





总结一共2个：scrollTop（字面意思） clientTop（局部正常基础少一点东西或者不正常，大局正常） offsetTop（正常）

```js
--1.固定（dom上常用属性）
clientWidth  //1.1屏幕（不固定）的宽高
width  //1.2屏幕（固定）宽高
scrollTop // 1.3滚动宽高

border-box下面，这三个一样， //1.3元素宽高
offsetHeight(元素本身的宽) | scrollHeight（元素高度-border*2+溢出来的元素高） | clientHeight（元素高度-border*2）

如果要是是content-box//1.3元素宽高
offsetHeight(元素+padding*2+border*2) | scrollHeight（元素高度+padding*2+溢出来的元素高-overflow-y: auto） | clientHeight（元素+padding*2）

//1.4元素距离顶部的距离
offsetTop（正常大全）
clientTop//顶部边框值
scrollTop:内部的滚动效果//document.querySelector(".box").scrollTop=100。（可以用来做页面滚动效果）

--2.事件：
clientX // 2.1以可见区域的左上角为原点
pageX // 2.2以页面本身的body为原点
offsetX（左内边框） | windowX （相对于屏幕）//2.3

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        .container {
            column-count: 2;
            margin-top: 800px;
        }

        .box {
            /* position: absolute; */
            top: 10px;
            margin: 10px;
            background: red;
            width: 100px;
            height: 100px;
            padding: 20px;
            box-sizing: border-box;
            word-wrap: break-word;
            border: 1px solid black;
            padding: 10px;
            overflow-y: auto;
        }

    </style>
    <div class="container">
        <div class="box"> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        </div>
        <div class="box"></div>
        <div class="box"></div>

        <div class="box"></div>

    </div>
    <script>

    </script>
</body>

</html>
```







```js
--0.基础知识

document.documentElement：可返回存在于 XML 以及 HTML 文档中的文档根节点（对应的是html标签）
document.body：提供了对 <body> 标签的直接访问（对应的是body标签）
在DTD已声明的情况下用documentElement，未声明的情况下用body



--1.可见区域宽高
document.documentElement.clientWidth;  //height + padding + 水平滚动条高度
window.screen.width//屏幕宽度（不受窗口resize事件影响）

document.documentElement.clientHeight;  //height + padding + 水平滚动条高度（doc为严格模式下面document.body失效，原因不明） | 考虑用document.documentElement.clientHeight
window.screen.height//屏幕高度（不受窗口resize事件影响）


2.滚动长度：
document.documentElement.scrollTop //严格模式下面用这个
document.body.scrollTop //兼容模式用这个

3.元素宽高
document.querySelector(".box").offsetWidth//获取元素的宽，这里需要注意我们的box-size:box还是content差距是很大的。

4.元素距离顶部距离
document.querySelector(".box").offsetTop//绝对数值

document.documentElement.scrollTop+document.documentElement.clientHeight,document.querySelector(".box").offsetTop
```









### 2.1.32 监听dom元素 | MutationObserver

```js
function callback(mutationList, observer) {
  mutationList.forEach((mutation) => {
    switch(mutation.type) {
      case 'childList':
        /* 从树上添加或移除一个或更多的子节点；参见 mutation.addedNodes 与
           mutation.removedNodes */
        break;
      case 'attributes':
        /* mutation.target 中某节点的一个属性值被更改；该属性名称在 mutation.attributeName 中，
           该属性之前的值为 mutation.oldValue */
        break;
    }
  });
}
var targetNode = document.querySelector("#someElement");
var observerOptions = {
  // 观察目标子节点的变化，是否有添加或者删除
  childList: true,  
  // 观察属性变动
  attributes: true, 
  // 观察后代节点，默认为 false
  subtree: true     
}

var observer = new MutationObserver(callback);
observer.observe(targetNode, observerOptions);

```



### 2.1.33 arguments

```js
arguments默认获取剩下的参数

function fun(age, className) {
    console.log(`${this.name}的年龄是${age}岁，是${className}班学生`)
}
```



...arguments

### 2.1.34 true | false | nan | 判空  | 易错

```js
if 里面我以为只有false的才会跳，结果现在发现了undefined，null，false都会跳

1.nan是number的特殊类型。不等于任何值，即使nan==nan返回值也是一个false，判断是否nan要调用isnan（）原理是会尝试转化number类型，能转化的返回true，否则返回false

2.false的情况
let a ; if(a){console.log("true")}else{console.log("no")}  //输出false
let a = 0  ; if(a){console.log("true")}else{console.log("no")}  //输出false
let a = NaN  ; if(a){console.log("true")}else{console.log("no")}  //输出false
let a = null  ; if(a){console.log("true")}else{console.log("no")}  //输出false
let a = ''  ; if(a){console.log("true")}else{console.log("no")}  //输出false

3.true的情况

let a = []  ; if(a){console.log("true")}else{console.log("no")}  //输出true
let a = {}  ; if(a){console.log("true")}else{console.log("no")}  //输出true
let a = -30  ; if(a){console.log("true")}else{console.log("no")}  //输出true
let a = '0'  ; if(a){console.log("true")}else{console.log("no")}  //输出true

4.object判空
JSON.stringify({})=='{}' == false
JSON.stringify([])=='[]' == false

let a={};a.length // a.length 这个玩意输出是undefine 
let a=[];a.length  // a.length 这个的输出是0



```



### 2.1.35  postmessage

#### 子组件

```js
let data="data1111111111"
window.postMessage(data,"*")  //parent.postmessage vue里面
```



#### 父组件

```js
function parent(param){
	console.log("测试:",param)
}
window.addEventListener("message",parent)

```

### 2.1.36 垃圾回收

```js
有一个方法，里面有一个基础数据类型 a，还有用 const 定义的 b 对象，怎么回收?（删除引用）
知识点：const定义的引用类型只要指针不发生改变，其他的不论如何改变都是可以的
function a() {
            setTimeout(() => {
                var b = 5;
                const c = {
                    data: [{ "id": 55 },]
                }
                //这样会报错 c={}，因为这样就改变了他的引用类型了
                c["data"]=[]
                console.log(c)
            },3000)

        }
        a()
```







### 2.1.37  innerText |  textContent |  nodeValue

```js
--1.innerText获取可以显示的文本:display:none的不会输出，opacticy为0就是可以被输出。

--2.textContent能够获取所有子节点的文本内容。包括html和script。注意注释获取不到

--3.nodeValue只能是作用于文本节点或者注释节点本点。不然会是null

--4.innertext作用于html element后两个作用于node。

--5.注意一下html中换行和和注释节点也被算做了一个子节点
```



### 2.1.38  geo api

```js
window.navigator.geolocation (http的定位可能会不准，因此最好是https-ios10)
//翻墙才能用
navigator.geolocation.getCurrentPosition(position => {
    console.log('当前位置信息：', position)
})

------------------------------
//定位数据获取成功响应  
function  onSuccess(position){  
      alert('纬度: '          + position.coords.latitude          + '\n' +  
      '经度: '         + position.coords.longitude         + '\n' +  
      '海拔: '          + position.coords.altitude          + '\n' +  
      '水平精度: '          + position.coords.accuracy          + '\n' +  
      '垂直精度: ' + position.coords.altitudeAccura)  
}  
//定位数据获取失败响应  
function onError(error) {  
  switch(error.code)  
  {  
    case error.PERMISSION_DENIED:  
    alert("您拒绝对获取地理位置的请求");  
    break;
    case error.POSITION_UNAVAILABLE:  
    alert("位置信息是不可用的");  
    break;
    case error.TIMEOUT:
    alert("请求您的地理位置超时");  
    break;
    case error.UNKNOWN_ERROR:  
    alert("未知错误");  
    break;
  }  
}  

if(navigator.geolocation){  
  navigator.geolocation.getCurrentPosition(onSuccess , onError);  
}else{  
  alert("您的浏览器不支持使用HTML 5来获取地理位置服务");  
}  
```



### 2.1.39  正则

```js
//(.)匹配任意一个 (？)匹配0-1个  *匹配1个以上 \d 匹配单个数字=[0-9]

//手机号 | 1开头+除了1之外的东西+中间9个结尾 
const reg = /^[1][3,4,5,6.7,8,9][0-9]{9}$/g;
const reg = /[1][3,4,5,6.7,8,9][0-9]{9}/g;
let text ="我的手机号是19120636253，因此xxxxx/但是他的手机号码是18928125079"
--1.match | 输出匹配的  这玩意和 replace是好用的 text.replace(reg,"替换的内容")
console.log(text.match(reg)) //['19120636253','18928125079']
--2.search | 返回第一个元素位置
console.log(text.match(reg)) //6
--3. test | 看一下有没有符合要求的元素..表单校验的时候可以用
console.log(reg.test(text)) // true
--4.零宽先行 断言 (?=p)  要求与p匹配	
//(?=a) 表示我们需要匹配某样东西的前面。  会带着?=一起输出出来，实操体验很差
//(?!a) 表示我们需要不匹配某样东西。
//(?<=a) 表示我们需要匹配某样东西的后面。
//(?<!a) 表示我们需要不匹配某样东西，与(?!a)方向相反。
var reg1 = /(?<=机号是)[0-9]{11}(?=,因)/g
let text ="我的手机号是19120636253,因此xxxxx但是他的手机号是18928125079,因但是,"
console.log(text.match(reg1))
console.log(reg1.exec(text))


var consoleName=["console","window.console"];
var consoleType= ["log", "info", "warn", "error" ,"assert" ,"count" ,"clear"];
//let rConsole = new RegExp("(" + consoleName.join("|") + ")" + ".(?:" + consoleType.join("|") + ")\\s{0,}\\([^;]*\\)(?!\\s*[;,]?\\s*\\/\\*\\s*NotClearConsole\\s*\\*\\/)\\s{0,};?", "gi");
let rConsole = /console.log\(.*?\)/g
let text ="console.log('ddddd');let a= 1;console.log('ddd')"
console.log(text.match(rConsole))
```



```js
	// 正则表达式
        function getQueryObject(url) {
            //假如不传值，默认也会有值
            url = url == null ? window.location.href : url
            //这一套组合技就是取到最后？后面的值
            // url.lastIndexOf('?')找到位置
            const search = url.substring(url.lastIndexOf('?') + 1)
            const obj = {}
            // 3.1 正则表达式 基本形式 /正则表达式主体/修饰符(可选)
            // i 大小不那啥  g 全局匹配 不会在匹配一个后就停止
            // JavaScript 中，正则表达式通常用于两个字符串方法 : 
            // search()-并返回子串的起始位置 和 replace()-替换 和 exec也常用
            const reg = /([^?&=]+)=/g       
// 先行断言 后行：后面的内容应匹配表达式 exp
        var reg1 = /(?=三).*(?=b)/
        console.log('123一二三abc'.match(reg1))
        // 返回三a

        console.log(reg1.exec(search))
        // reg.exec(search,(rs, $1, $2) => {
        //         console.log($1, "$1")
        //         console.log($2, "$2")
        //         console.log(rs, "rs")
        //         const name = decodeURIComponent($1)
        //         let val = decodeURIComponent($2)
        //         val = String(val)
        //         obj[name] = val
        //         return rs
        // })

        //这样子写可以得到第一个参数匹配的内容
        // replace的第一个参数是正则表达式，第二个参数有两种形式，第一种是string，那就是替换了
        // 第二种就是传入函数，rs是匹配的内容，$1是第一个括号匹配的内容，$2是第二个括号匹配的内容
        // 如果除了这两个参数外还有的话，那么就是offset（匹配到的索引）,str（原始字符串）
        // reg是正则表达式，传入
        search.replace(reg, (rs, $1, $2) => {
            console.log($1, "$1")
            console.log($2, "$2")

            const name = decodeURIComponent($1)
            let val = decodeURIComponent($2)
            val = String(val)
            obj[name] = val
            return rs
        })

        return obj
    }
	console.log("window.location", getQueryObject())
```

### 2.1.40 正则中使用变量

```js
 function count(str,all){
        let reg =new RegExp(`${str}`,"g")
        let temp = all.match(reg)
        return temp
    }
```










## 2.2 快问快答

```js
1.从哪里学习
开源项目排名，mdn，codepen
```



## 2.3 项目中js高级



### 2.3.1 js引入 css js

```js
//1.引入script
    const scriptInfo = document.createElement("script")
    scriptInfo.type = "text/javascript"
    // scriptInfo.setAttribute("data-callType","callScript")
    scriptInfo.src = "/js/1.js"
    document.head.appendChild(scriptInfo)

    //2.引入css
    setTimeout(() => {
        const cssInfo = document.createElement("link")
        cssInfo.rel = "stylesheet"
        cssInfo.type="text/css"
        cssInfo.href="/css/1.css"
        document.head.appendChild(cssInfo)
    }, 10);

    //删除
let callScript = document.querySelector("script[data-callType='callScript']")
document.head.removeChild(callScript)
```





### 2.3.2 禁止自动滑动

```js
 document.body.addEventListener('touchmove', function(e){
     e.preventDefault();
 }, { passive: false });  //passive 参数不能省略，用来兼容ios和android
```



### 2.3.3 canvas成图片

```js
//blob允许我们可以通过js直接操作二进制数据
      document.querySelector('.test').toBlob(function(blob) {
        var a = document.createElement("a");
        var body = document.getElementsByTagName("body");
        document.body.appendChild(a);
        a.download = "img" + ".jpg";
        a.href = window.URL.createObjectURL(blob);

        a.click();
        body.removeChild("a");
      });
```



### 2.3.4 iframe | postmessage

#### 2.3.4.1 利用iframe进行通讯



这里对src进行了一个参数的传参

```html
<h3>postmessage的协议测试：发送端</h3>
<iframe :src="'http://localhost:8082?getparam='+getparam" width="300px" height="300px" frameborder="0"></iframe>

```



```html
<h3>postmessage的协议测试：接收端</h3>
    {{receive}}
 this.receive=this.$route.query.getparam
```



#### 2.3.4.2 postMessage进行通讯



##### 子传父

例如子组件的按钮点击后传递给父组件

用vue用post有一个坑就是，他的webpack初始化的时候会先给自己发一个数据。导致data会是webpack报错。
如果说我们要实现postMessage只发一次，我们就要监听指定的窗口

子：

```js
//可以在method中，也可以在mount中
//最后一个是可以传过去的网址
parent.postMessage({msg:"这是发送过去的数据"}, '*')
```



父：

```js
//可以在method中，也可以在mount中
//http://localhost:8082是iframe的内容
// const publisher=window.open("http://localhost:8082/")
//父目前的情况
<iframe :src="'http://localhost:8082?getparam='+getparam" width="300px" height="300px" frameborder="0"></iframe>

//子传父的情况
window.addEventListener("message", (event)=>{
    var origin = event.origin;
    console.log(origin)
    // 通常，onmessage()事件处理程序应当首先检测其中的origin属性，忽略来自未知源的消息
    // 不然的话webpack会先给他发一个包
    if (origin !== "http://localhost:8082"){
       return;
    }
	console.log(event,"postmessage")
    //false就是冒泡事件，从里到外
}, false);

```







##### 父传子

父：

```js
 //html中的东西
<iframe
      :src="'http://localhost:8082?getparam=' + getparam"
      width="300px"
      height="300px"
      frameborder="0"
      id="iframeViewer"
    ></iframe>


const _iframe = document.getElementById("iframeViewer").contentWindow;
    const iframeViewer = document.getElementById("iframeViewer");
    let _obj = "父传子的数据";
    // _obj.type = "view";
    // _obj.currentProcessInstanceId =1;

    iframeViewer.onload = () => {
      console.log("iframeViewer已加载");
      _iframe.postMessage((_obj), "*");
    };



```



子：

```js
window.addEventListener("message", function (event) {
      if(event.origin=='http://localhost:8081'){
        console.log(event)
      }
});
```













## 2.4 webgl

### 2.4.1 webgl基础

```js
类型数据和array的联系:类型数组不等于array。类型数组提升了数组的性能。array的内部实现是链表，因此元素多的话性能会比较差(这里主要指的是访问)。类型数组是连续的内存实现的数据类型，通过加法可以实现访问，array则是一个个查找

类型数组:实现是缓冲(arraybuffer 内存中的二进制数据。可以简单地理解为数据)+视图(int8array u的意思是有符号的正数范围增大，没有负数 uint8array uint16array float32array将缓冲中的数据读取和访问出来，可以简单地理解为数据转化器)。缓存包括视图

类型数组常用方法:get(index) set(index，value) length 不支持push pop。唯一的创造方法是
let a=new int8array([1，1，1])
```



### 2.4.2 实操

总结起来四个步骤：

```js
1，initwebgl（初始化webgl） 
2，initshader(初始化着色器)
3，initbuffer（创造buffer对象）
4，draw
```



主要api：

webgl的移动主要是向量的知识
1，shadersource的第二个参数的字符串定义一下angle旋转角度
2，在initbuffer中对angle进行赋值。通过webgl.uniformif(angle，pi/180)

```js
1。初始化
第一步：查找元素
第二步:这个元素getcontext("canvas")，获取上下文 
第三步:初始化画布，xx.viewport(左上角的x坐标，y坐标，clientwidth，clientheight)


2.着色器(顶点着色器(计算坐标+一部分颜色)。片元着色器(最终颜色，纹理))
#创造shader
createshader
#链接shader。这里的第二个参数是void main开头的源码，还挺难的。有点像c的代码
shadersource
#编译shader
compileshader
#创造程序
createprogram
#shader绑定到程序里面
attachprogram
#webgl跟program链接
linkprogram
#使用program
useprogram




3，创造buffer(圈一块地)
#顶点数据
let a=new int8array([1，1，1])
然后这个画布.createbuffer()
#绑定缓冲区对象
这个画布.bindbuffer
#绑定缓冲区数据
这个画布.binddata
#允许传递，允许传递给shader(cpu渲染管线)。之后调用显卡
enableverrexattrbarray
#传递给位置变量 shader和js做通信
这个画布.vertexattribpointer


4，最后绘制就可以了
drawarray


```







接口：/wechat_api/auth/getOpenidStatus 

猜测原因：边界处理异常

```json
这个接口返回结果如下
let res = {
    WeiVi: "XJW ♥ ZJY 2021.10.27 - Forever.", 
 	code: 0, 
 	data: {}, 
 	msg: "尚未完善手机号注册"
}

前端在这个接口后面执行
if (res.code == 0){
        this.setData({
        openid: res.data.openid,
        newuser: true,
        token: res.data.token
	})
}

这导致后续/wechat_api/auth/openidRegister接口的openid和token参数传参为空。才报错参数有误后跳转回主界面

solution：
手机号注册没有完善的时候正常返回openid和token
或者
在openidRegister增加对于openid和token为空的处理
```





## 2.5 js工程化概述

```js
--1 工程化工具.js,rollup gulp
--2.模块化：es6 
--3.兼容：
--3.1 polyfill：
@babel/preset-env + corejs@3
--3.2 runtime：
@babel/preset-env + @babel/runtime-corejs3 + @babel/plugin-transform-runtime
```





### 2.5.1 polyfill 实操

#### 2.5.1.1 jsconfig.json

```js
{
    "target": "es2015", // 指定要使用的默认库，值为"es3","es5","es2015"...
    "compilerOptions": {
        "module": "commonjs", // 在生成模块代码时指定模块系统
        "experimentalDecorators": true,
        "compilerOptions": {
            "incremental": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度
            "tsBuildInfoFile": "./buildFile", // 增量编译文件的存储位置
            "diagnostics": true, // 打印诊断信息 
            "target": "ES5", // 目标语言的版本
            "module": "CommonJS", // 生成代码的模板标准
            "outFile": "./app.js", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置"module": "AMD",
            "lib": ["DOM", "ES2015", "ScriptHost", "ES2019.Array"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入"ES2019.Array",
            "allowJS": true, // 允许编译器编译JS，JSX文件
            "checkJs": true, // 允许在JS文件中报错，通常与allowJS一起使用
            "outDir": "./dist", // 指定输出目录
            "rootDir": "./", // 指定输出文件目录(用于输出)，用于控制输出目录结构
            "declaration": true, // 生成声明文件，开启后会自动生成声明文件
            "declarationDir": "./file", // 指定生成声明文件存放目录
            "emitDeclarationOnly": true, // 只生成声明文件，而不会生成js文件
            "sourceMap": true, // 生成目标文件的sourceMap文件
            "inlineSourceMap": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中
            "declarationMap": true, // 为声明文件生成sourceMap
            "typeRoots": [], // 声明文件目录，默认时node_modules/@types
            "types": [], // 加载的声明文件包
            "removeComments":true, // 删除注释 
            "noEmit": true, // 不输出文件,即编译后不会生成任何js文件
            "noEmitOnError": true, // 发送错误时不输出任何文件
            "noEmitHelpers": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用
            "importHelpers": true, // 通过tslib引入helper函数，文件必须是模块
            "downlevelIteration": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现
            "strict": true, // 开启所有严格的类型检查
            "alwaysStrict": true, // 在代码中注入'use strict'
            "noImplicitAny": true, // 不允许隐式的any类型
            "strictNullChecks": true, // 不允许把null、undefined赋值给其他类型的变量
            "strictFunctionTypes": true, // 不允许函数参数双向协变
            "strictPropertyInitialization": true, // 类的实例属性必须初始化
            "strictBindCallApply": true, // 严格的bind/call/apply检查
            "noImplicitThis": true, // 不允许this有隐式的any类型
            "noUnusedLocals": true, // 检查只声明、未使用的局部变量(只提示不报错)
            "noUnusedParameters": true, // 检查未使用的函数参数(只提示不报错)
            "noFallthroughCasesInSwitch": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)
            "noImplicitReturns": true, //每个分支都会有返回值
            "esModuleInterop": true, // 允许export=导出，由import from 导入
            "allowUmdGlobalAccess": true, // 允许在模块中全局变量的方式访问umd模块
            "moduleResolution": "node", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入
            "baseUrl": "./", // 解析非相对模块的基地址，默认是当前目录
            "paths": { // 路径映射，相对于baseUrl
              // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置
              "jquery": ["node_modules/jquery/dist/jquery.min.js"]
            },
            "rootDirs": ["src","out"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错
            "listEmittedFiles": true, // 打印输出文件
            "listFiles": true// 打印编译的文件(包括引用的声明文件)
          }
     
    },
    "exclude": [ // 要排除的文件
        "node_modules",
        "**/node_modules/*"
    ],
    "checkJs": false, // 启用javascript文件的类型检查
    "baseUrl": "*", // 解析非相关模块名称的基础目录
    "paths": {
        "utils": [
            "src/utils/*"
        ] // 指定相对于baseUrl选项计算的路径映射，使用webpack别名，智能感知路径
    },
}
```









## 2.6 加载字体







## 2.7 tc39 会议

```js
2023/1
1.temporal时区的国际化支持
2.原型怎么用symbol防止污染
3.weakmap的key将支持用symbol表示
4.await置于顶层的推进，await将引入promise的一些特性方案的推进

2023/1之前

--0.1 Top-level await（stage 4）：支持最顶层使用await
--0.2 Temporal（stage 3）：时间处理函数标准化 函数
--0.3（stage3） at ： 负索引
--0.4 Record & Tuple（stage2） ：Record类似于对象，Tuple类似于数组
--0.5 Decorators (stage 2)：装饰器
--0.6 Set Methods (stage 2)：基于交集/并集/差集创建新的Set的方法
--0.7 orient-error编程的一系列接口
--0.8 Pipeline Operator：管道操作符（|>） 如doubleNumber(number)会变为number |> doubleNumber的形式

--0.9.throw Expressions (stage 2)
let x = throw new Error("Unsupported encoding");

--0.10.Promise.try  可以更加精确的捕获同步错误。
里面抛出的错误能够被捕获
function getUserNameById(id) {
    return Promise.try(function() {
        if (typeof id !== "number") {
            throw new Error("id must be a number");
        }
        return db.getUserById(id);
    }).then((user)=>{
        return user.name
});
}
--0.11.Error Cause

就是throw new Error('Upload job result failed', { cause: err });
然后 是使用 。相当于他会帮你自定义一个类型出来
try {
  await doJob();
} catch (e) {
  console.log(e);
  console.log('Caused by', e.cause);
}
// Error: Upload job result failed
// Caused by TypeError: Failed to fetch
```



