# 4.性能优化

[[toc]]

渲染前的性能优化可以了解一下。前端性能优化分为两类：一类是文件加载更快、另一类是文件渲染更快



## 10.0 代码分析

```js
//1.BundleAnalyzer 分析打包大小
//2.speedmeasure：分析加载速度

```





## 10.1 编译速度

webpack编译的时候加速

```js
//1.threadloader-第一次编译的时候慢一点。后面贼快
//2.Terser 也可以在编译的时候
//3.swc loader增加ast 解析速度
```





## 10.2  加载速度

### 10.2.1  体积压缩

```js
//1.js压缩：terser压缩-原理-1.删除注释，空格，换行符 2.变量名压缩 3.提前计算4.console.log 去除

//2.image压缩：imagemin-原理-1.例如png会把24位的图片信息压缩成8位的信息 

//3.css压缩：cssnano+postcss-原理-1.删除注释，空格 2.变量名压缩

//4.js压缩：还有一个压缩是利用webpack的压缩optimization（优化器）进行代码分包。
//常用的是chunkIds（算法：可以选择named-短期缓存和detaerministic-长期缓存）和splitChunks（主要是里面的cacheGroups verndor的test-正则匹配名字和minChunk-最小引用数 一般来说呢.多引用的会专门分包）

//5.
```



### 10.2.2 网络请求

```js
//1.使用长连接
//2.雪碧图/精灵图
//3.节流防抖
```





包 后套套，包 前 cp，中间gls。最后acg
包后压缩ttcnb treeshaking terser  cache nano（css体积）imagemin-webpack browlist
中间性能：glspf  prefetch     gzip split跟cachegroup一起用 loader 
包前tscpd cache swc thread pnpm dllplugin
分析 speedmeasure bundleanalyse

## 10.3 渲染速度

### 

```js
1.缓存（HTTP缓存、本地缓存、Vue的keep-alive缓存等）
2.提前渲染：ssr服务器端渲染
3. 避免渲染阻塞：CSS放在HTML的head中 JS放在HTML的body底部 
4.懒加载
5.对dom查询进行缓存、将dom操作合并、使用减少重排的标签
```

## 10.4 学到的东西