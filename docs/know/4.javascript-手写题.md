# 4.JS手写题

[[toc]]

## 4.1.防抖节流

```js
/**
 * 
 * @param {*} fn 
 * @param {*} time 
 * @example 两个的示例是一样的 function a(){console.log("data")};let b=new debounce(a,1000);b()
 */
// 最后一次 input输入 防抖
function debounce(fn,time){
    window.flag =null;
    return function(){
        clearTimeout(window.flag)
        window.flag=setTimeout(()=>{
            fn()
        },time)
    }
}

// 第一次 滚动 节流
/**
 * 
 * @param {*} fn  方法
 * @param {*} time  时间
 * @returns 节流用于下拉加载
 */
function thorttle(fn,time){
    window.flag =null;
    return function(){
        if(!window.flag){
            window.flag =true;
            fn();
            setTimeout(()=>{
                window.flag =false;
            },time)
        }
    }
}
```



## 4.2.数组扁平化

```js

function flatten(arr) {
    var rets = [];
    for(var i = 0; i < arr.length; i ++) {
        if (Array.isArray(arr[i])) {
            rets = rets.concat(flatten(arr[i]));
        } else {
            rets.push(arr[i]);
        }
    }
    return rets;
}


```

## 4.3.curry | 柯里化

```js
//不固定参数的
const curryObject = (fn) => {
    window.arr = []
    return function recursive(arguments) {
        // 返回一个函数,用这个函数接受后面传递的新参数
        return (newArgs) => {
            // window.arr=fn(...arguments.concat(newArgs))  不这样做object要糟糕
            let output = arguments.concat(newArgs)
            console.log(output,"output")
            window.arr=fn(output)
            // return recursive(...arguments.concat(newArgs));
            return recursive(arguments.concat(newArgs));
        };
    };
};

//固定参数的
 const curryArray = (fn) => {
    window.arr = []
    return function recursive(...arguments) {
        // 返回一个函数,用这个函数接受后面传递的新参数
        return (...newArgs) => {
            window.arr=fn(...arguments.concat(newArgs))
            // return recursive(...arguments.concat(newArgs));
            return recursive(...arguments.concat(newArgs));
        };
    };
};
```

## 4.4.手写promise

```js
function myPromise(constructor) {
    let self = this
    self.status = 'pending'
    self.value = undefined
    self.error = undefined
    function resolve(value) {
        if(self.status === 'pending') {
            self.status = 'resolved'
            self.value = value
        }
    }
    function reject(error) {
        if(self.status === 'pending') {
            self.status = 'rejected'
            self.error = error
        }
    }
    try {
        constructor(resolve, reject)
    }catch(e) {
        reject(e)
    }
}

myPromise.prototype.then = function(onFullfilled, onRejected) {
    if(this.status === 'resolved') onFullfilled(this.value)
    else if(this.status === 'rejected') onRejected(this.error)
}

new myPromise((resolve, reject) => {
    resolve(1)
}).then(x => console.log(x))
```

## 4.5.手写Events(发布订阅)

```js
class eventBus {
    constructor() {
        this.eventBus = {
            // 保存类型与回调的容器
            event: {
            }
        }
    }
    // 绑定事件
    on = (name, event) => {
        // 判断
        if (this.eventBus.event[name]) {
            this.eventBus.event[name].push(event);
        } else {
            // 如果 event 属性中不存在该类型事件,就往里存
            this.eventBus.event[name] = [event];
        }
    };
    // 触发事件
    emit = (name, data) => {
        // 判断
        if (this.eventBus.event[name] ) {
            this.eventBus.event[name].forEach(event => {
                // 执行回调
                event(data);
            })
        }
    }

    // 事件解绑
    off = (eventName) => {
        // 若传入了 eventName
        if (this.eventBus.event.hasOwnProperty(eventName)) {
            // 只是删除对应的事件回调
            delete this.eventBus.event[eventName];
        } else {
            this.eventBus.event = {};
        }
    }
    say = ()=>{
        console.log(this.eventBus)
    }
}
```







调用

```js
let test = new eventBus()
    test.on('login', data => {
     console.log(data + '用户已登录')
})
test.emit('login', "admin")
```

## 4.6.数组去重

```js
/**
 * 
 * @param {*} arr 
 * @des hash
 */
function unique(arr,e){
    let hash = {}; //定义一个hash表
    let arr1 = []; //定义一个新数组
    for(let i=0;i<arr.length;i++){
      if(!hash[arr[i][e]]){
        hash[arr[i][e]] = true;
        arr1.push(arr[i]);
      }
    }
    return arr1;  
}

/**
 * @param {Array} arr
 * @des set 方法
 */
function uniqueArr(arr) {
  return Array.from(new Set(arr))
}
```

## 4.7.去除字符串首尾空格

```js
let str = '  jjjj   jjjj   '
let p = /(^\s*)|(\s*$)/g
let res = str.replace(p, '')
console.log(res)
```

## 4.8.单例模式

```js
let Head = (function() {
    let HeadClass = function() {}
    let instance 
    return function() {
        if(instance) return instance
        instance = new HeadClass()
        return instance
    }
})()

let a = new Head()
let b = new Head()
console.log(a===b)
```

## 4.9.下划线命名法转换驼峰命名法（JS）

```js
let str = 'firstname'
function func(s) {
    let index = s.indexOf('_')
    if(index === -1) return s
    return s.slice(0,index)+s.charAt(index+1).toUpperCase()+s.slice(index+2,s.length)
}
console.log(func(str))
```

## 4.10.手写bind

考察对于this的理解

```js
//有点像是curry化。但是bind要对第一个object和this（function）做处理
Function.prototype.myBind = function() {
    // 1.拿到将来调用 myBind 方法的函数.因为是谁调用它就指向他的
    let fn = this 
    //2.arguments 会把参数组合起来
    let args = [...arguments]
    //3.分离this  object对象 和 参数
    const ctx = args.shift()
    // 4.返回一个函数
    return function() { 
        //5....arguments是实例化后传入的参数3，
        //args是bind的时候传入的参数18,100,1000，并且已经去除了第一个
        //ctx就相当于把object绑定上去了
        fn.call(ctx,args, ...arguments)
    }
}

// 对应到 myBind 中的 ctx。也就是被改变后的 this
const obj = {
    name: '小明',
    age:"56"
}

function fun(age, className) {
    console.log(`${this.name}的年龄是${age}岁，是${className}班学生`)
}

const temp = fun.myBind(obj, 18) 
temp("三") 
```

## 4.11.手写chunk函数

loash里面的东西，可以把数组分块

```js
// 按照size把arr分隔成若干个数组
function chunk(arr, size) {
    let res = []
    while(arr.length) {
        res.push(arr.splice(0,size))
    }
    return res;
}
let arr = [1,5,6,9,8,7,4];
chunk(arr,2)

```

## 4.12.手写promise.all

```js
function promiseAll(args) {
    let promises = Array.of(...args)
    let values = []
    return new Promise((resolve, reject) => {
        promises.forEach((item, index) => {
            Promise.resolve(item).then(value => {
                values.push(value)
                if(values.length === promises.length) resolve(values)
            }, reason => {
                reject(reason)
            })
        })
    })
}

let input = []
for(let i=0;i<5;i++) {
    input.push(new Promise(resolve => {
        setTimeout(()=>{
            resolve(i)
        },1000*i)
    }))
}
promiseAll(input).then(data => console.log(data))
```

## 4.13.手写map（考察对map的理解）

```js
// Array.map((value,index,array) => {}, thisArg)
// thisArg 是 第一个参数（函数）的this指针
Array.prototype.myMap = function(fn, thisArg) {
    let res = []
    for(let index = 0;index < this.length; index++) {
        res.push(fn.call(thisArg,this[index],index,this))
    }
    return res
}
Array.prototype.myMap = function(fn, thisArg) {
    return this.reduce((res,value,index) => {
        res.push(fn.call(thisArg,value,index,this))
        return res
    },[])
}
let arr = [1,2,3,4]
console.log(arr.myMap((value,index) => {
    return value + index
}))
```

## 4.14.生成海报保存本地的实现 

用canvas将html转换为图片，使用a标签定义href和download属性并执行click函数



## 4.15.手写快速排序

```js
/**
 * 
 * @param {*} data :array  
   let temp = [1,5,2,5,6,9]
   quickSort(temp)
 */
function quickSort(data){
    if(data.length<=1){
        return data
    }
    let left = []
    let right = []
    let temp = data[0]
    for(let i=1;i<data.length;i++){
        if(data[i]>=temp){
            right.push(data[i])
        }else{
            left.push(data[i])
        }
    }
    return quickSort(left).concat([temp],quickSort(right))
}

```





## 4.16.平面转化树形

```js
let data =[
    		{ id: 1, parentId: 1, name: "一级菜单A", rank: 1 },
            { id: 2, parentId: 1, name: "一级菜单B", rank: 1 },
            { id: 3, parentId: 1, name: "一级菜单C", rank: 1 },
            { id: 4, parentId: 0, name: "二级菜单A-A", rank: 2 },
            { id: 5, parentId: 4, name: "二级菜单A-A", rank: 2 },
            { id: 6, parentId: 5, name: "二级菜单A-A", rank: 2 },
            { id: 7, parentId: 6, name: "二级菜单A-A", rank: 2 },
    		{ id: 8, parentId: 6, name: "二级菜单A-A", rank: 2 }
]

--方法一：两层for循环
function flatToTree(arr){
    let result = [];
    arr.forEach((re)=>{
        re.child = arr.filter(res =>{
            return res.parentId === re.id 
        })
        console.log("test:",re)
        if(re.parentId==0){
            result.push(re)
        }   
        console.log("test:",result)
    })
	return result
}
flatToTree(data)


--方法二：hash表

let data =[
    		{ id: 1, parentId: 0, name: "一级菜单A", rank: 1 },
            { id: 2, parentId: 1, name: "一级菜单B", rank: 1 },
            { id: 3, parentId: 1, name: "一级菜单C", rank: 1 },
            { id: 4, parentId: 0, name: "二级菜单A-A", rank: 2 },
            { id: 5, parentId: 4, name: "二级菜单A-A", rank: 2 },
            { id: 6, parentId: 5, name: "二级菜单A-A", rank: 2 },
            { id: 7, parentId: 6, name: "二级菜单A-A", rank: 2 },
    		{ id: 8, parentId: 6, name: "二级菜单A-A", rank: 2 }
]
function arrayToTree(arr){
  const map = {};
    //初始化id
  for (let value of arr) {
    map[value['id']] = value;
  }
  for (let value of arr) {
    let key = value['parentId'];
    // 找到父节点，找不到就跳过（顶级节点是没有parent的）
    if (!(key in map)) continue;
    map[key].children = (map[key].children || []).concat(value);
  }
   //返回parentId为1的
  return map;
};
console.log(arrayToTree(data));

```

## 4.17.树形转化扁平array

```js
let output1 = [
    {
        "id": 1,
        "parentId": 0,
        "name": "一级菜单A",
        "children": [
            {
                "id": 2,
                "parentId": 1,
                "name": "二级菜单A-A",
                "children": [
                    {
                        "id": 3,
                        "parentId": 2,
                        "name": "二级菜单A-A",
                        "children": [
                            {
                                "id": 4,
                                "parentId": 3,
                                "name": "二级菜单A-A",
                                "children": [                     
                                    {
                                        "id": 5,
                                        "parentId": 4,
                                        "name": "二级菜单A-A",
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    }
]

function treeToArray(arr){
    let result = []
    for(let i = 0 ; i<arr.length ; i++){
        if(JSON.stringify(arr[i].children)=='[]'){
            result.push(arr[i])
        }else{
            result.push(arr[i])
            result = result.concat(treeToArray(arr[i].children)) 
        }
    }
    return result
}
treeToArray(output1)
```



## 4.18 深拷贝

```js
let obj = { name: 'toto' }
let arr = [ obj ]

obj = null

如果这么写的话，对象不会从内存中移除
```



```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj == null) return obj; // 如果是null 或者undefined 直接返回
  // 正则表达式或者日期对象 直接返回
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if (typeof obj !== 'object') return obj;
  // 如果hash中已经有obj了  直接返回
  if (hash.has(obj)) return hash.get(obj);
  // 剩下的认为是对象或者数组   new它的constructor  获得一个新的数组或对象
  let newObj = new obj.constructor();
  // 把obj放到映射表中
  hash.set(obj, newObj);
  // 遍历老对象  并设置新对象的key为老对象key对应的值
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = deepClone(obj[key], hash);
    }
  }
  return newObj;
}


function deepclone(obj , hash = new WeakMap()){
    if(obj==null){return obj}
    if (typeof obj !== 'object') return obj;
    
}



```



