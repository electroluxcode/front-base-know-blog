# 2.2. ts

[[toc]]

https://www.typescriptlang.org/play?#code/FAAhQ

## 2.1 基本

安装

```shell
npm install typescript -g  #这一步之后就可以执行  tsc test.ts 命令了
npm i -g ts-node
node xxx.js
```





### 2.2.1 base type

```js
let param: string = "测试"; //number boolean
// console.log(param);
```



### 2.1.2  array | enum

```js
enum Color {Red = 1, Green, Blue} Color.Green;

--1.数组集合
// let paramArray:string[] =["1","6"] 
let paramArray: Array<string> = ["1", "6"]

--2.枚举
enum Color {Red = 1, Green=2, Blue=3} 
console.log(Color.Red)


```





### 2.1.3  union type 

```js
//方法| 如果参数传值是传入方法的话，那么是Function
function add(param:string):void  {
    return "测试"
}

// 联合数据类型
let a: string | number = 2;
```



### 2.1.4   interface

```typescript
// 对象简单一点直接 :object也可以
// 类型断言/接口
interface IUser {
    id:number,
    // 5.1表示这个变量可有可无（可选属性），不加？如果不加上name会报错
    // 5.2或者 使用的变量 加上 as Iuser(类型断言)
    name?: string,
    // 5.3只读属性(字面意思)
    readonly age:number;
    // 5.3只读属性(字面意思)
    callback1?:(admin:string) => string
}
//5.5函数 类型 （形参）
interface Ifunction{
    (source: string): void;
}
let ceshiFunction:Ifunction=(testParam)=>{
    console.log(testParam)
    return "dd"
}
// 1212
ceshiFunction("函数断言")
// 5.6 如果interface里面 想加入你的属性 ，就要用类型断言
let b:IUser = {
    id: 45,
    age:8,
    name1:12,
    callback1:(test:string):string=>{
        return test
    }
} as IUser ;
b.id=5
b.callback1=(admin)=>{
    console.log(admin)
    return admin
}
b.callback1("断言45454545")
// b.age=5
// console.log(b)


```



### 2.1.5  type  | &  |

```ts
type Method = 'GET' | 'POST'

function dd(url: string, method: Method) {
    console.log('lll');

};

let option = {
    url: 'https:',
    method: 'POST'
}
dd(option.url, option.method as Method)


interface t1 {x: number; y: number}
interface t2 {x: number; y: number; z: number}

type tAll =t2 | t1 // 不报错，这个是共性
// type tAll =t2 & t1 // 报错，这个是合集

const p: tAll = {
    x:2,
    y:3,
    z:3
}
```





### 2.1.6  as   |  !  |  ？|  !! |  ??  | 

```ts
--1.as 非常简单这里不讲

--2.! 感叹号
function aa(value?:string){
    //加上 ! 的意思是确保value一定是有值的
    console.log(value!.length);
}
aa('ppp')；

--3.? 可选链操作符 
如果不存在的时候会直接返回undefined。如果存在会继续执行
xx?.length
--4. !!  | ??
!! 80  //输出true
?? 空值判断 //左边是空值就输出右边   例如   let a = "test";ss??'你好'
```



### 2.1.7 class

```ts
--1. 基础
class Car { 
    // 字段 
    engine:string; 
 
    // 构造函数 
    constructor(engine:string) { 
        this.engine = engine 
    }  
 
    // 方法 
    disp():void { 
        console.log("发动机为 :   "+this.engine) 
    } 
}

--2. 继承 | super | instanceof
子类只能继承一个父类
class miniCar extends Car {
    disp:void{
        console.log("miniCar:  "+ this.engine)
        super.disp()
    }
}
console.log(new miniCar() instanceof miniCar)
```



### 2.1.8 declare | export

```js
.d.ts 文件中的顶级声明必须以 "declare" 或 "export" 修饰符开头。

"declare" 和 "export" 不要混用，不然declare 就没有导出的功能了

注意，如果在普通文件中，declare 直接写 跟不写用处差不多。简单来说他是用于 .d.ts 之类的全局类型的


```





### 2.1.9  extends（继承）|  implements（实现）

```js
--1.extends（继承）:
一个新的接口或者类,从父类或者接口继承所有的属性和方法,不可以重写属性,但可以重写方法
--2.implements（实现）:
实现，一个新的类，从父类或者接口实现所有的属性和方法，同时可以重写属性和方法，包含一些新的功能

所以说。extends 一般是 类之间的继承（大） 。  implement一般是类属性之间的共性，然后提取出来
```







### 2.1.10 Partial 

```ts
Partial<> 这句话的意思是DefaultOptons 都变成 可选链？。相当是子集
//这句话的意思是 继承了DefaultOptons的所有属性，但是requestUrl必须传入
export interface Options extends Partial<DefaultOptons> {
    requestUrl: string,
}
```

### 2.1.11 enum妙用 | 魔鬼字符串

```ts
export enum TrackerConfig {
    version = '1.0.0'
}
```

### 2.1.12.泛型 | 妙用

```ts
在type/index.ts中
interface DefaultOptons {
    // 接口地址
    requestUrl: string | undefined,
    // dom事件追踪
    domTracker: boolean,
    // sdk版本
    sdkVersion: string | number,
    // js的报错 | promise 报错
    jsError:boolean
}

另一个文件中


import {DefaultOptons} from "../types/index"
return <DefaultOptons>{
      sdkVersion: "1.0",
      domTracker: false,
      jsError: false
}
```

### 2.1.13 assign 后面的object会覆盖掉前面相同object

```ts
let temp1 = {
	name:"xiaoming",
	number:5
}

let temp2 = {
	name:"xiaohone"
}
console.log(Object.assign(temp1,temp2))

{ 
    "name": "xiaohone",
    "number": 5
}
```

### 2.1.14.html 常用类型

```ts
HTMLElement
HTMLImageElement   有src
HTMLAnchorElement   有src
```

### 2.1.15. ts 类型兼容

```ts
//(最好不要这样写),一个类型就对应一个就好了，没有必要
class和对象interface成员多的可以赋值给成员少的-被给予的对象的属性要求必须都有
函数参数少的可以赋值给参数多的-被给予的对象属性无所谓
class t1 {x: number; y: number}
class t2 {x: number; y: number; z: number}
const p: t2 = new t1()  //报错
let temp = 
```

### 2.1.16. 泛型

这玩意相当于一个变量

####  泛型<>约束 | 添加约束

```ts
--1.基本约束（[]）
// function id<T>(value: T): T {return value}
function id<T>(value: T[]): T[] {return value}
// 调用泛型函数
//const num = id<number>(10)
const num = id<number>([10])


--2.自定义约束(extends + 可选 &)
interface Length {length: number}
interface Width {width:number}
function id<T extends Length & Width>(v: T) {return v.length+v.width}

--3.keyof object的type展开变成成员类型

interface Width {width:number;id:number}
function id<T extends keyof Width >(v: T) {return v}
id("id")
```

### 9. keyof 妙用（对象展开成key的联合类型）

这玩意是展开一个的key，可以这样确定object 中一定有这个key

```ts
function getProperty<T extends object, K extends keyof T>(
  obj: T, key: K
) {
  return obj[key];
}
```

### 10.pick <> 从Type中选择一组属性来构造新类型

```ts
interface Props {
	id: string
	name: string
	children: number[]
}
type PickProps = Pick<Props,'id' | 'name'>
```

### 11.Record

```ts
Record<Keys,Type>  Record用来定义对象的键和值

interface PageInfo {
	title: string
}

type Page = "home" | "about" | "contact";

const nav : Record<Page, PageInfo> = {
	about: {title, "about"},
	home: {title, "home"},
	contact: {title, "contact"}
};
```

### 12.索引签名类型

```
[key: string]来约束接口中出现的实现名称，这样obj中可以出现任意多个属性
```



### 13.基于对象生成

集体给一个变量

```ts
type Props = {a: number;b: string;c: boolean}
// 多一步keyof获取对象属性
// 将a,b,c都变成了number
type Type3 = {[key in keyof Props]: number}
```





## 2.2 进阶





### 2.2.1 原理

```js
--1.一个class 从 ts 编译成 js
--1.1 class 会变成 var 变量，然后 {} 整体会变成一个 class{}名字所组成的一个函数.constructor 会 和之前的声明合并
--1.2 class {} 里面的方法会挂在到原型prototype上面
--1.3 private 和 public 对编译后的代码没有任何影响
--1.4 
```





### 2.2.2 tsconfig配置

https://www.tslang.cn/docs/handbook/compiler-options.html

```ts
第一行是我认为要的
注意：下面都包含在 "compilerOptions" 这个 数组里面
--1."skipLibCheck":true    默认值是false 
改成 true 忽略所有的声明文件（ *.d.ts）的类型检查

--2."forceConsistentCasingInFileNames": true   默认值是false
改成 true 禁止对同一个文件的不一致的引用

--3."isolatedModules": false,    默认值是false。 
如果改成 true 就必须要在每一个文件都要导出了

--4."noImplicitAny":true      默认值是false。 
改成 true 就 在表达式和声明上有隐含的 any类型时报错。但是如果是自己做项目的话，设置成false也可以

--5."strict":false 
alwaysStrict : 每一行加上 "use strict"
noImplicitAny: 有any 就会报错
strictNullChecks ： 不能用null 来赋值

--6.suppressImplicitAnyIndexErrors:true   索引签名缺失可能会报错
这里的配置我们可以参考下面
interface user {
    id:number,
    name:string,
    data:{
        //这个写法似乎只能在对象中用
        [key : string] : string | string[]
    }
}
let ob :user =  {
    id : 2,
    name : "d",
    data:{
	
    }
}


然后接下来的是根目录中经常用的东西
//**表示任意目录   *表示任意文件
// 指定需要编译文件 否则默认当前目录下除了exclude之外的所有.ts, .d.ts,.tsx 文件
"include": ["./test.ts"],
// 指定需要编译文件 否则默认当前目录下除了exclude之外的所有.ts, .d.ts,.tsx 文件
"files": ["./src/**/*"],
// 不编译某些文件
"exclude": ["test.ts"],


```







```js
--1. 函数组件
React.FC<unknown> = () => {}


--2. 忽略报错
// @ts-nocheck
忽略整一个文件的报错

--3.TABLE 没用等一下删掉

--4.useState<boolean>(false);

--5. 例如我们要下载 react-router 包 。我们可以npm install @types/xxxxx包，用这种方式可以解决变量缺失的情况

--6.常用类型
--6.1 array 类型   
const names2: string[] = [] // 推荐

--6.2 object 对象
interface Base {
    // 路由路径
    path: string;
    // 路由组件
    component?: any;
}
难一点，对象里面还有一个对象
export interface IRoute extends Base {
  children?: IRoute[];
}

--6.3  




```



### 2.2.3 一些可能出现的bug

```
.d.ts


tsconfig.json 引入后才有效
```





### 2.2.4 {id:1;name:{xx:23}}

```ts
interface user {
    id: number,
    name: string,
    data: {
        [key: string]: string | string[]
    }
}
let ob: user = {
    id: 2,
    name: "d",
    data: {
        IdleDeadline: "2"
    }
}
```



### 2.2.5  [{},{},{}]

```ts
type roleType = Array<{
  value:string,
  label:string
}>
```



### 2.2.6 window |  sdk 声明

```js
利用的是 interface 类型的合并特性

// 2.Window 类似的 像一些 sdk和引入的包 我们也可以这样用。
// 这里需要在 index.d.ts中  declare interface Window {a:any}
// 或者  declare namespace Window {a:any}
// window.a = 3
```







### 2.2.4 项目常用

```ts



document.querySelector(".src").focus();
document.querySelector(".src").innerText="d23232sa"
document.querySelector(".red-button").click()



// 0 . 可以像右边一样引入 ///  <reference path = "index.d.ts" />
///  <reference path = "index.d.ts" />

// 1.复杂一点的变量

// 3. 不同格式文件
// 这里需要在 index.d.ts中  declare module '*.png';
import A from "1.png"

// 4.命名空间 declare namespace API 
/**
 declare namespace API {
    interface Result {code?:number;message?:string; data:object
    }
 }
 */
let Result : API.Result = {
    code:200,
    data:{
    }
}

// 5. 函数的写法 declare function getName(params:string) :void
// getName()

// 6.类的写法  declare class test {id:number;static name ="test";constructor(param:number){this.id=param}}
// new test(2)

// 7. 一些奇怪的对象 declare function $(param:string):void
function $(){}

// 8.模块   这玩意 不适合 弄变量 第三方模块用吧
/**
 declare module abcd {
  export function abcdF(param:string):void
  export let id:number;
}
 */
module abc {
    export let id:number;
}
abc.id = 3
// 引入模块

// temp()
// console.log(temp)

// 9.umd 就是可以通过全局变量访问到，也可以通过require的方式访问到 
// 其实就是按照全局的方式写d.ts（modules），写完后在最后加上declare namespace "xxx"的描述：

//10.扩展内置对象 的 某一个 方法  
/**
  interface Array(){
    quickSort(arr:Array<number>):Array<number>
  }
 */


// 11.
list

```





### 2.2.5 写插件的一些思路



```ts
1.解决key的一些问题
// 解决key
interface ob {
    [key: string]: any
}

用的话就是 Partial<ob>就可以了

2.声明class 只用 
class speechBot {
    public speechProgress
    constructor(param:speechBotType ) {
        this.speechProgress = window.speechSynthesis
    }
} 

export default new speechBot({
    text: "测试",
})
这样就可以了

3.然后可以给用户一些默认的属性（主类方法中）
class Tracker {
    public data: DefaultOptons;
    public constructor(options: Options) {
        this.data = Object.assign(this.init(), options)
        this.installTrack()
    }
    //初始化默认参数
    private init(): DefaultOptons {
        return <DefaultOptons>{ 
            userConfig: {useId:"测试用户",mode:"plugin"},
            sdkVersion: TrackerConfig.version,
        }
    }
    //根据用户的选择在这里开启
    private installTrack() {
        if (this.data) {
            console.log("data:", this.data)
        }
    }
}


```





### 2.2.6 ref 

```ts
const backgroundRef = useRef<HTMLImageElement | null >(null);

ref={backgroundRef }
```





### 2.2.7 装饰器模式

```ts
/**
 * 
 * @param {*} msg 
 * @param {*} options 
 * @returns 
 */

function errorHandle(msg: string, options: any) {
    return function (target: any, key: any, descriptor: any) {
        let fn = descriptor.value;
        descriptor.value = function (...args: any[]) {
           try{
               fn()
           }
            catch{
                console.log(msg,options)
            }
        }
    }
}

class test{
    @errorHandle("errorGet方法报错",{url:"index.ts中25行报错"})
    public  errorGet(){
        throw("哈哈哈哈哈")
    }
}
new test().errorGet()
```





## 2.3公用的一些utils ts

测试可以：tsc xxx.ts

### 2.3.1 eventbus

```js
class eventBus {
    eventBus:{
        [key:string]:any
    }
    constructor() {
        this.eventBus = {
            // 保存类型与回调的容器
            event: {
            }
        }
    }
    // 绑定事件
    on = (name:string, event:Function) => {
        this.eventBus.event[name]=event
    };
    // 触发事件
    emit = (name:string, data:any) => {
        // 判断
        if (this.eventBus.event[name] ) {
            this.eventBus.event[name](data)
        }
    }

    // 事件解绑
    off = (eventName:string) => {
        // 若传入了 eventName
        if (this.eventBus.event.hasOwnProperty(eventName)) {
            // 只是删除对应的事件回调
            delete this.eventBus.event[eventName];
        } else {
            this.eventBus.event = {};
        }
    }
    say = ()=>{
        console.log(this.eventBus)
    }
}
let eventbus = new eventBus()
export {eventbus}

// 使用类似于
父文件中
eventbus.on("测试", (data: string) => {
    console.log("触发了该死的事件:" + data)
})

子文件中
import {eventbus} from "./eventBus"
eventbus.emit("测试",type)   

```





### 2.3.2  cache

工程化中最好是新建一个cache文件夹，然后里面放上自己的文件

```ts
class Cache {
    cacheData: {
        [key: string]: Array<object>
    }
    constructor() {
        this.cacheData = {
        }
    }
    set(name: string, item: any) {
        this.cacheData[name] = item
    }
    get(name: string) {
        const res = this.cacheData[name]
        return res
    }
    delete(name: string) {
        Reflect.deleteProperty(this.cacheData, name);
    }
    add(name: string, data: object) {
        if (this.cacheData[name]) {
            this.cacheData[name].push(data)
        }else{
            this.cacheData[name] = []
            this.cacheData[name].push(data)
        }
    }
}

export default new Cache()
```



### 2.3.3 error

```ts

import cache from "./cache"

interface baseConfig {
    logConfig: {
        isLog: boolean
    }
}
interface errMsgConfig {
    code: number
    msg: string
    data: object
    date:string
}
class errLog {
    public baseConfig : baseConfig
    constructor(param: baseConfig) {
        this.baseConfig = Object.assign(this.init(), param)
    }
    private init(): baseConfig {
        return <baseConfig>{
            logConfig: {
                isLog: true,
            }
        }
    }
    public errLogGet() {
        return cache.get("errorLog")
    }
    public errLogAdd(param: errMsgConfig) {
        param.date=""+""+new Date().getFullYear()+new Date().getMonth()+new Date().getDay()+new Date().getHours()+new Date().getMinutes()+new Date().getSeconds()
        cache.add("errorLog",param)
        return cache.get("errorLog")
    }
   
}

export default new errLog({
    logConfig:{
        isLog:true, 
    }
}) 
```



### 2.3.4  speakbot

```ts
/**
 let ceshi = new speechBot({
    text: "测试",
    pitch: 1,
    rate: 1,
    volume: 20,
    lang: 'zh-CN'
})
ceshi.speak("ddddddddd33")
ceshi.cancel()
 */

interface speechBotType  {
    text:string,
    pitch:number,
    rate:number,
    volume:number,
    lang:string
}
class speechBot {
    public speechProgress
    public speechApi
    constructor(param:speechBotType ) {
        this.speechProgress = window.speechSynthesis
        this.speechApi = new SpeechSynthesisUtterance()
        this.speechApi.text = param.text ?? "没传入文本"
        this.speechApi.rate = param.rate ?? 1
        this.speechApi.volume = param.volume ?? 1
        this.speechApi.lang = param.lang ?? "zh-CN"
        this.speechApi.pitch = param.pitch ?? 1.5
 
    }
    speak = function (text:string) {
        // console.log(text,this.speechProgress)
        this.speechApi.text = text
        this.speechProgress.speak(this.speechApi)
    }
    pause = function () {
        this.speechProgress.pause()
    }
    resume = function () {
        // 暂停和非暂停切换
        this.speechProgress.resume()
    }
    cancel = function () {
        // 删除所有话语
        this.speechProgress.cancel()
    }
    configGet = function () {
        // console.log(this.speechProgress.getVoices())
    }
}

export default new speechBot({
    text: "测试",
    pitch: 1,
    rate: 1,
    volume: 20,
    lang: 'zh-CN'
})


```

### 2.3.5  listenerbot

```ts
class listener {
    constructor(param) {
        this.config = {
            beginText: "小圆",
            endText: "结束",
            aliveTime: 3
        }
        this.text = ""
        this.speechRecognition = new webkitSpeechRecognition({
            lang:"cmn-Hans-CN"
        })
        let that =this
        this.speechRecognition.onaudiostart = (event) => {
            console.log(`onsoundstart: `,event);

        };
        this.speechRecognition.onaudioend = (event) => {
            console.log(`onsoundend:`,event);
            setTimeout(()=>{
                that.start()
            },3500)
        };
        this.speechRecognition.onerror = (event) => {
            console.log(`报错信息: ${event.error}`);
            setTimeout(()=>{
                that.start()
            },3500)
        };
    }
    start() {
        console.log("begin");
        this.speechRecognition.start()
        this.speechRecognition.onresult = function (event) {
            let results = event.results
            console.log(results)
            if (results.length > 0) {
                for (var i = 0; i < results.length; i++) {
                    this.text = results[i][0].transcript
                    console.log(this.text)
                    if(this.text.includes("你好")){
                        let utterance1 = new SpeechSynthesisUtterance("你好")
                        window.speechSynthesis.speak(utterance1)
                    }
                    // document.querySelector("textarea").innerHTML = text
                }
            }
        }
        this.speechRecognition.continuous = true
        // this.speechRecognition.start()
    }
    end() {
        console.log("end");
        this.speechRecognition.stop()

    }
    alive() {
        console.log("alive")
    }
}
new listener().start()
```







### 2.3.6 tdk

```ts


interface baseParam {
    title: string
    description: string
    keywords: string
    [key: string]: any
}
class tdk {
    public config: baseParam
    constructor(param: baseParam) {
        this.config = {
            title: "",
            keywords: "",
            description: "",
        }
        this.config.title = param?.title
        this.config.keywords = param?.keywords
        this.config.description = param?.description
        this.main()
    }
    main() {
        let keywords = document.querySelector("meta[name=keywords]")
        let title = document.querySelector("title")
        let description = document.querySelector("meta[name=description]")
        this.service("keywords", keywords)
        this.service("title", title)
        this.service("description", description)
    }
    service(key: string, element: Element | null) {
        if (key == "title") {
            element.innerHTML = this.config?.title
            return
        }
        let keywords = element
        if (keywords) {
            keywords.setAttribute("content", this.config[key])
        } else {
            let temp = document.createElement("meta")
            temp.setAttribute("name", "keywords")
            temp.setAttribute("content", this.config.keywords)
        }
    }
}

// export  default tdk
/**
 new tdk({
    title:"你好",
    keywords:"",
    description:"",
 })
 */
```



### 2.3.7 ajax

```ts
interface AjaxRequest {
    method: 'GET' | 'get' | 'POST' | 'post'
    url: string
    data?: any // post
}

interface AjaxResponse {
    [prop: string]: any
}
//注意是async 引用的时候可以await
async function ajax(options: AjaxRequest): Promise<AjaxResponse> {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const method = options.method.toUpperCase();

        if (method === 'GET') {
            xhr.open(method, options.url, true);
        }

        if (method === 'POST') {
            xhr.open(method, options.url, true);
            xhr.setRequestHeader('Content-type', 'application/json');
            xhr.send(JSON.stringify(options.data));
        } else {//GET
            xhr.send();
        }

        xhr.onreadystatechange = () => {
            // xhr.readyState == 4 请求已完成，且响应已就绪
            if (xhr.readyState !== 4 || xhr.status === 0) return;
            const responseData: AjaxResponse = JSON.parse(xhr.response);
            // 当 readyState 等于 4 且status为 200 时，表示响应已就绪：
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve(responseData);
            } else {
                reject(`request failed with status code ${xhr.status}`);
            }
        };
    });
}
/**
const result = await ajax({
    method: 'GET',
    url: 'http:localhost:10088/get?id=2',
    data: {
        // redirectURI
    }
});

console.log(result)
 */


```

